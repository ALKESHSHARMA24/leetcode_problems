
//c++ code

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        //If List Contain a Single or 0 Node
        if(head == NULL || head ->next == NULL)
            return head;
        
        
        ListNode *temp = NULL;
        ListNode *slow = head;
        ListNode *fast = head;
        
        // 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)
        while(fast !=  NULL && fast -> next != NULL)
        {
            temp = slow;
            slow = slow->next;          //slow increment by 1
            fast = fast ->next ->next;  //fast incremented by 2
            
        }   
        temp -> next = NULL;            //end of first left half
        
        ListNode* l1 = sortList(head);    //left half recursive call
        ListNode* l2 = sortList(slow);    //right half recursive call
        
        return mergelist(l1, l2);         //mergelist Function call
            
    }
    
    //MergeSort Function O(n*logn)
    ListNode* mergelist(ListNode *l1, ListNode *l2)
    {
        ListNode *ptr = new ListNode(0);
        ListNode *curr = ptr;
        
        while(l1 != NULL && l2 != NULL)
        {
            if(l1->val <= l2->val)
            {
                curr -> next = l1;
                l1 = l1 -> next;
            }
            else
            {
                curr -> next = l2;
                l2 = l2 -> next;
            }
        
        curr = curr ->next;
        
        }
        
        //for unqual length linked list
        
        if(l1 != NULL)
        {
            curr -> next = l1;
            l1 = l1->next;
        }
        
        if(l2 != NULL)
        {
            curr -> next = l2;
            l2 = l2 ->next;
        }
        
        return ptr->next;
    }
};

---------------------------------------------------------------------java code--------------------------------------------------

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode sortList(ListNode head) {
        // If list contains a single or 0 node
        if(head == null || head.next == null)
            return head;
        
        ListNode temp = null;
        ListNode slow = head;
        ListNode fast = head;
        
        // 2 pointer approach / turtle-hare Algorithm (Finding the middle element)
        while(fast != null && fast.next != null) {
            temp = slow;
            slow = slow.next;           // slow increments by 1
            fast = fast.next.next;     // fast incremented by 2
        }   
        temp.next = null;               // end of first left half
        
        ListNode l1 = sortList(head);   // left half recursive call
        ListNode l2 = sortList(slow);   // right half recursive call
        
        return mergeList(l1, l2);       // mergeList function call
            
    }
    
    // MergeSort Function O(n*logn)
    public ListNode mergeList(ListNode l1, ListNode l2) {
        ListNode ptr = new ListNode(0);
        ListNode curr = ptr;
        
        while(l1 != null && l2 != null) {
            if(l1.val <= l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        
        // For unequal length linked list
        if(l1 != null) {
            curr.next = l1;
            l1 = l1.next;
        }
        
        if(l2 != null) {
            curr.next = l2;
            l2 = l2.next;
        }
        
        return ptr.next;
    }
}
